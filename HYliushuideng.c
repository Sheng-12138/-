/*************************C51红外遥控控制led灯的亮灭(51最小系统板)
							接线说明:
							+    --VCC            -   --GND
							USB转TTL:                
							RXD--TXD              TXD --RXD
							led灯组                   --	P2     
							红外接收模块的信号端      --  P3^2
							OLED显示屏:
							SDA                       --  P0^0
							SCL                       --  P0^1
*********************************************************************/

#include<reg52.h>                           //头文件
#include<intrins.h>		                   //因为要用到左右移函数，所以加入这个头文件

//**********函数定义声明**********//
void delay(unsigned int z); 
void delay_us(unsigned int aa); 

/************* 定义函数类型******************/
typedef unsigned char INT8U;
typedef unsigned char uchar;

typedef unsigned int INT16U;
typedef unsigned int uint;


 /*****************接口位定义****************************/

sbit IR  = P3^2;     //定义红外脉冲数据接口为P3^2	（外部中断0输入口）

//sbit liushui=P2;
//*******声明变量类型*********//

uchar IRtime; 		         //检测红外高电平持续时间（脉宽）进行判断
uchar IRcord[4];            //定义数组，用于储存分离出来的4个字节的数据（用户码2个字节+键值码2个字节）
uchar IRdata[33];          //定义数组，用于储存红外的33位数据（第一位为引导码用户码16+键值码16）
bit IRpro_ok, IRok;       //第一个用于红外接收4个字节完毕。IRok用为检测脉宽完毕

unsigned char leddat_2[50]=                   //花式流水灯2，循环一次叠加一个灯亮，全部计加满后，闪烁两下
{
	0x01,0x02,0x04,0x08,0x10,0x20,0x40,0x80,0x81,0x82,
	0x84,0x88,0x90,0xa0,0xc0,0xc1,0xc2,0xc4,0xc8,0xd0,
	0xe0,0xe1,0xe2,0xe4,0xe8,0xf0,0xf1,0xf2,0xf4,0xf8,
	0xf9,0xfa,0xfc,0xfd,0xfe,0xff,0xff,0x00,0xff,0x00,0xff
};

/////////////***********************OLED显示屏英文数字字库**********************************/////////
//常用ASCII表，字库
/*取模方式：共阴——列行式——逆向输出*/
const unsigned char code zf[] =
{
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0
  0x00, 0x00, 0x00, 0xF8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x33, 0x30, 0x00, 0x00, 0x00, //! 1
  0x00, 0x10, 0x0C, 0x06, 0x10, 0x0C, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, //" 2
  0x40, 0xC0, 0x78, 0x40, 0xC0, 0x78, 0x40, 0x00, 0x04, 0x3F, 0x04, 0x04, 0x3F, 0x04, 0x04, 0x00, //# 3
  0x00, 0x70, 0x88, 0xFC, 0x08, 0x30, 0x00, 0x00, 0x00, 0x18, 0x20, 0xFF, 0x21, 0x1E, 0x00, 0x00, //$ 4
  0xF0, 0x08, 0xF0, 0x00, 0xE0, 0x18, 0x00, 0x00, 0x00, 0x21, 0x1C, 0x03, 0x1E, 0x21, 0x1E, 0x00, //% 5
  0x00, 0xF0, 0x08, 0x88, 0x70, 0x00, 0x00, 0x00, 0x1E, 0x21, 0x23, 0x24, 0x19, 0x27, 0x21, 0x10, //& 6
  0x10, 0x16, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, //' 7
  0x00, 0x00, 0x00, 0xE0, 0x18, 0x04, 0x02, 0x00, 0x00, 0x00, 0x00, 0x07, 0x18, 0x20, 0x40, 0x00, //( 8
  0x00, 0x02, 0x04, 0x18, 0xE0, 0x00, 0x00, 0x00, 0x00, 0x40, 0x20, 0x18, 0x07, 0x00, 0x00, 0x00, //) 9
  0x40, 0x40, 0x80, 0xF0, 0x80, 0x40, 0x40, 0x00, 0x02, 0x02, 0x01, 0x0F, 0x01, 0x02, 0x02, 0x00, //* 10
  0x00, 0x00, 0x00, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x01, 0x1F, 0x01, 0x01, 0x01, 0x00, //+ 11
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0xB0, 0x70, 0x00, 0x00, 0x00, 0x00, 0x00, //, 12
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, //- 13
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, //. 14
  0x00, 0x00, 0x00, 0x00, 0x80, 0x60, 0x18, 0x04, 0x00, 0x60, 0x18, 0x06, 0x01, 0x00, 0x00, 0x00, /// 15
  0x00, 0xE0, 0x10, 0x08, 0x08, 0x10, 0xE0, 0x00, 0x00, 0x0F, 0x10, 0x20, 0x20, 0x10, 0x0F, 0x00, //0 16
  0x00, 0x10, 0x10, 0xF8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x20, 0x3F, 0x20, 0x20, 0x00, 0x00, //1 17
  0x00, 0x70, 0x08, 0x08, 0x08, 0x88, 0x70, 0x00, 0x00, 0x30, 0x28, 0x24, 0x22, 0x21, 0x30, 0x00, //2 18
  0x00, 0x30, 0x08, 0x88, 0x88, 0x48, 0x30, 0x00, 0x00, 0x18, 0x20, 0x20, 0x20, 0x11, 0x0E, 0x00, //3 19
  0x00, 0x00, 0xC0, 0x20, 0x10, 0xF8, 0x00, 0x00, 0x00, 0x07, 0x04, 0x24, 0x24, 0x3F, 0x24, 0x00, //4 20
  0x00, 0xF8, 0x08, 0x88, 0x88, 0x08, 0x08, 0x00, 0x00, 0x19, 0x21, 0x20, 0x20, 0x11, 0x0E, 0x00, //5 21
  0x00, 0xE0, 0x10, 0x88, 0x88, 0x18, 0x00, 0x00, 0x00, 0x0F, 0x11, 0x20, 0x20, 0x11, 0x0E, 0x00, //6 22
  0x00, 0x38, 0x08, 0x08, 0xC8, 0x38, 0x08, 0x00, 0x00, 0x00, 0x00, 0x3F, 0x00, 0x00, 0x00, 0x00, //7 23
  0x00, 0x70, 0x88, 0x08, 0x08, 0x88, 0x70, 0x00, 0x00, 0x1C, 0x22, 0x21, 0x21, 0x22, 0x1C, 0x00, //8 24
  0x00, 0xE0, 0x10, 0x08, 0x08, 0x10, 0xE0, 0x00, 0x00, 0x00, 0x31, 0x22, 0x22, 0x11, 0x0F, 0x00, //9 25
  0x00, 0x00, 0x00, 0xC0, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x30, 0x00, 0x00, 0x00, //: 26
  0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x60, 0x00, 0x00, 0x00, 0x00, //; 27
  0x00, 0x00, 0x80, 0x40, 0x20, 0x10, 0x08, 0x00, 0x00, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x00, //< 28
  0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x00, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x00, //= 29
  0x00, 0x08, 0x10, 0x20, 0x40, 0x80, 0x00, 0x00, 0x00, 0x20, 0x10, 0x08, 0x04, 0x02, 0x01, 0x00, //> 30
  0x00, 0x70, 0x48, 0x08, 0x08, 0x08, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x30, 0x36, 0x01, 0x00, 0x00, //? 31
  0xC0, 0x30, 0xC8, 0x28, 0xE8, 0x10, 0xE0, 0x00, 0x07, 0x18, 0x27, 0x24, 0x23, 0x14, 0x0B, 0x00, //@ 32
  0x00, 0x00, 0xC0, 0x38, 0xE0, 0x00, 0x00, 0x00, 0x20, 0x3C, 0x23, 0x02, 0x02, 0x27, 0x38, 0x20, //A 33
  0x08, 0xF8, 0x88, 0x88, 0x88, 0x70, 0x00, 0x00, 0x20, 0x3F, 0x20, 0x20, 0x20, 0x11, 0x0E, 0x00, //B 34
  0xC0, 0x30, 0x08, 0x08, 0x08, 0x08, 0x38, 0x00, 0x07, 0x18, 0x20, 0x20, 0x20, 0x10, 0x08, 0x00, //C 35
  0x08, 0xF8, 0x08, 0x08, 0x08, 0x10, 0xE0, 0x00, 0x20, 0x3F, 0x20, 0x20, 0x20, 0x10, 0x0F, 0x00, //D 36
  0x08, 0xF8, 0x88, 0x88, 0xE8, 0x08, 0x10, 0x00, 0x20, 0x3F, 0x20, 0x20, 0x23, 0x20, 0x18, 0x00, //E 37
  0x08, 0xF8, 0x88, 0x88, 0xE8, 0x08, 0x10, 0x00, 0x20, 0x3F, 0x20, 0x00, 0x03, 0x00, 0x00, 0x00, //F 38
  0xC0, 0x30, 0x08, 0x08, 0x08, 0x38, 0x00, 0x00, 0x07, 0x18, 0x20, 0x20, 0x22, 0x1E, 0x02, 0x00, //G 39
  0x08, 0xF8, 0x08, 0x00, 0x00, 0x08, 0xF8, 0x08, 0x20, 0x3F, 0x21, 0x01, 0x01, 0x21, 0x3F, 0x20, //H 40
  0x00, 0x08, 0x08, 0xF8, 0x08, 0x08, 0x00, 0x00, 0x00, 0x20, 0x20, 0x3F, 0x20, 0x20, 0x00, 0x00, //I 41
  0x00, 0x00, 0x08, 0x08, 0xF8, 0x08, 0x08, 0x00, 0xC0, 0x80, 0x80, 0x80, 0x7F, 0x00, 0x00, 0x00, //J 42
  0x08, 0xF8, 0x88, 0xC0, 0x28, 0x18, 0x08, 0x00, 0x20, 0x3F, 0x20, 0x01, 0x26, 0x38, 0x20, 0x00, //K 43
  0x08, 0xF8, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x3F, 0x20, 0x20, 0x20, 0x20, 0x30, 0x00, //L 44
  0x08, 0xF8, 0xF8, 0x00, 0xF8, 0xF8, 0x08, 0x00, 0x20, 0x3F, 0x00, 0x3F, 0x00, 0x3F, 0x20, 0x00, //M 45
  0x08, 0xF8, 0x30, 0xC0, 0x00, 0x08, 0xF8, 0x08, 0x20, 0x3F, 0x20, 0x00, 0x07, 0x18, 0x3F, 0x00, //N 46
  0xE0, 0x10, 0x08, 0x08, 0x08, 0x10, 0xE0, 0x00, 0x0F, 0x10, 0x20, 0x20, 0x20, 0x10, 0x0F, 0x00, //O 47
  0x08, 0xF8, 0x08, 0x08, 0x08, 0x08, 0xF0, 0x00, 0x20, 0x3F, 0x21, 0x01, 0x01, 0x01, 0x00, 0x00, //P 48
  0xE0, 0x10, 0x08, 0x08, 0x08, 0x10, 0xE0, 0x00, 0x0F, 0x18, 0x24, 0x24, 0x38, 0x50, 0x4F, 0x00, //Q 49
  0x08, 0xF8, 0x88, 0x88, 0x88, 0x88, 0x70, 0x00, 0x20, 0x3F, 0x20, 0x00, 0x03, 0x0C, 0x30, 0x20, //R 50
  0x00, 0x70, 0x88, 0x08, 0x08, 0x08, 0x38, 0x00, 0x00, 0x38, 0x20, 0x21, 0x21, 0x22, 0x1C, 0x00, //S 51
  0x18, 0x08, 0x08, 0xF8, 0x08, 0x08, 0x18, 0x00, 0x00, 0x00, 0x20, 0x3F, 0x20, 0x00, 0x00, 0x00, //T 52
  0x08, 0xF8, 0x08, 0x00, 0x00, 0x08, 0xF8, 0x08, 0x00, 0x1F, 0x20, 0x20, 0x20, 0x20, 0x1F, 0x00, //U 53
  0x08, 0x78, 0x88, 0x00, 0x00, 0xC8, 0x38, 0x08, 0x00, 0x00, 0x07, 0x38, 0x0E, 0x01, 0x00, 0x00, //V 54
  0xF8, 0x08, 0x00, 0xF8, 0x00, 0x08, 0xF8, 0x00, 0x03, 0x3C, 0x07, 0x00, 0x07, 0x3C, 0x03, 0x00, //W 55
  0x08, 0x18, 0x68, 0x80, 0x80, 0x68, 0x18, 0x08, 0x20, 0x30, 0x2C, 0x03, 0x03, 0x2C, 0x30, 0x20, //X 56
  0x08, 0x38, 0xC8, 0x00, 0xC8, 0x38, 0x08, 0x00, 0x00, 0x00, 0x20, 0x3F, 0x20, 0x00, 0x00, 0x00, //Y 57
  0x10, 0x08, 0x08, 0x08, 0xC8, 0x38, 0x08, 0x00, 0x20, 0x38, 0x26, 0x21, 0x20, 0x20, 0x18, 0x00, //Z 58
  0x00, 0x00, 0x00, 0xFE, 0x02, 0x02, 0x02, 0x00, 0x00, 0x00, 0x00, 0x7F, 0x40, 0x40, 0x40, 0x00, //[ 59
  0x00, 0x0C, 0x30, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x06, 0x38, 0xC0, 0x00, //\\ 60
  0x00, 0x02, 0x02, 0x02, 0xFE, 0x00, 0x00, 0x00, 0x00, 0x40, 0x40, 0x40, 0x7F, 0x00, 0x00, 0x00, //] 61
  0x00, 0x00, 0x04, 0x02, 0x02, 0x02, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, //^ 62
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, //_ 63
  0x00, 0x02, 0x02, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, //` 64
  0x00, 0x00, 0x80, 0x80, 0x80, 0x80, 0x00, 0x00, 0x00, 0x19, 0x24, 0x22, 0x22, 0x22, 0x3F, 0x20, //a 65
  0x08, 0xF8, 0x00, 0x80, 0x80, 0x00, 0x00, 0x00, 0x00, 0x3F, 0x11, 0x20, 0x20, 0x11, 0x0E, 0x00, //b 66
  0x00, 0x00, 0x00, 0x80, 0x80, 0x80, 0x00, 0x00, 0x00, 0x0E, 0x11, 0x20, 0x20, 0x20, 0x11, 0x00, //c 67
  0x00, 0x00, 0x00, 0x80, 0x80, 0x88, 0xF8, 0x00, 0x00, 0x0E, 0x11, 0x20, 0x20, 0x10, 0x3F, 0x20, //d 68
  0x00, 0x00, 0x80, 0x80, 0x80, 0x80, 0x00, 0x00, 0x00, 0x1F, 0x22, 0x22, 0x22, 0x22, 0x13, 0x00, //e 69
  0x00, 0x80, 0x80, 0xF0, 0x88, 0x88, 0x88, 0x18, 0x00, 0x20, 0x20, 0x3F, 0x20, 0x20, 0x00, 0x00, //f 70
  0x00, 0x00, 0x80, 0x80, 0x80, 0x80, 0x80, 0x00, 0x00, 0x6B, 0x94, 0x94, 0x94, 0x93, 0x60, 0x00, //g 71
  0x08, 0xF8, 0x00, 0x80, 0x80, 0x80, 0x00, 0x00, 0x20, 0x3F, 0x21, 0x00, 0x00, 0x20, 0x3F, 0x20, //h 72
  0x00, 0x80, 0x98, 0x98, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x20, 0x3F, 0x20, 0x20, 0x00, 0x00, //i 73
  0x00, 0x00, 0x00, 0x80, 0x98, 0x98, 0x00, 0x00, 0x00, 0xC0, 0x80, 0x80, 0x80, 0x7F, 0x00, 0x00, //j 74
  0x08, 0xF8, 0x00, 0x00, 0x80, 0x80, 0x80, 0x00, 0x20, 0x3F, 0x24, 0x02, 0x2D, 0x30, 0x20, 0x00, //k 75
  0x00, 0x08, 0x08, 0xF8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x20, 0x3F, 0x20, 0x20, 0x00, 0x00, //l 76
  0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x00, 0x20, 0x3F, 0x20, 0x00, 0x3F, 0x20, 0x00, 0x3F, //m 77
  0x80, 0x80, 0x00, 0x80, 0x80, 0x80, 0x00, 0x00, 0x20, 0x3F, 0x21, 0x00, 0x00, 0x20, 0x3F, 0x20, //n 78
  0x00, 0x00, 0x80, 0x80, 0x80, 0x80, 0x00, 0x00, 0x00, 0x1F, 0x20, 0x20, 0x20, 0x20, 0x1F, 0x00, //o 79
  0x80, 0x80, 0x00, 0x80, 0x80, 0x00, 0x00, 0x00, 0x80, 0xFF, 0xA1, 0x20, 0x20, 0x11, 0x0E, 0x00, //p 80
  0x00, 0x00, 0x00, 0x80, 0x80, 0x80, 0x80, 0x00, 0x00, 0x0E, 0x11, 0x20, 0x20, 0xA0, 0xFF, 0x80, //q 81
  0x80, 0x80, 0x80, 0x00, 0x80, 0x80, 0x80, 0x00, 0x20, 0x20, 0x3F, 0x21, 0x20, 0x00, 0x01, 0x00, //r 82
  0x00, 0x00, 0x80, 0x80, 0x80, 0x80, 0x80, 0x00, 0x00, 0x33, 0x24, 0x24, 0x24, 0x24, 0x19, 0x00, //s 83
  0x00, 0x80, 0x80, 0xE0, 0x80, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1F, 0x20, 0x20, 0x00, 0x00, //t 84
  0x80, 0x80, 0x00, 0x00, 0x00, 0x80, 0x80, 0x00, 0x00, 0x1F, 0x20, 0x20, 0x20, 0x10, 0x3F, 0x20, //u 85
  0x80, 0x80, 0x80, 0x00, 0x00, 0x80, 0x80, 0x80, 0x00, 0x01, 0x0E, 0x30, 0x08, 0x06, 0x01, 0x00, //v 86
  0x80, 0x80, 0x00, 0x80, 0x00, 0x80, 0x80, 0x80, 0x0F, 0x30, 0x0C, 0x03, 0x0C, 0x30, 0x0F, 0x00, //w 87
  0x00, 0x80, 0x80, 0x00, 0x80, 0x80, 0x80, 0x00, 0x00, 0x20, 0x31, 0x2E, 0x0E, 0x31, 0x20, 0x00, //x 88
  0x80, 0x80, 0x80, 0x00, 0x00, 0x80, 0x80, 0x80, 0x80, 0x81, 0x8E, 0x70, 0x18, 0x06, 0x01, 0x00, //y 89
  0x00, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x00, 0x00, 0x21, 0x30, 0x2C, 0x22, 0x21, 0x30, 0x00, //z 90
  0x00, 0x00, 0x00, 0x00, 0x80, 0x7C, 0x02, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3F, 0x40, 0x40, //{ 91
  0x00, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, //| 92
  0x00, 0x02, 0x02, 0x7C, 0x80, 0x00, 0x00, 0x00, 0x00, 0x40, 0x40, 0x3F, 0x00, 0x00, 0x00, 0x00, //} 93
  0x00, 0x06, 0x01, 0x01, 0x02, 0x02, 0x04, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, //~ 94
};
//宏定义
#define u8 unsigned char 
#define u16 unsigned int
#define u32 unsigned long
#define Max_Column	128
#define Max_Row		64 

//***************OLED端口定义*****************//

sbit OLED_SDIN=P0^0;            //SDA
sbit OLED_SCL=P0^1;             //SCL


//IIC Stop

void IIC_Stop()
{
	OLED_SCL = 1 ;
	OLED_SDIN = 0;
	OLED_SDIN = 1;

}
void IIC_Wait_Ack()
{
	OLED_SCL = 1 ;
	OLED_SCL = 0;
}
// IIC Write byte

void Write_IIC_Byte(u8 IIC_Byte)
{
	u8 i;
	u8 m, da;
	da = IIC_Byte;
	OLED_SCL = 0;
	for(i = 0; i < 8; i++)
	{
		m = da;
		m = m & 0x80;
		if(m == 0x80)
		{
			OLED_SDIN = 1;
		}
		else OLED_SDIN = 0;
		da = da << 1;
		OLED_SCL = 1;
		OLED_SCL = 0;
	}
}
//IIC Start
void IIC_Start()
{
	OLED_SCL = 1;
	OLED_SDIN = 1;
	OLED_SDIN = 0;
	OLED_SCL = 0;
}
// IIC Write Command
void Write_IIC_Command(u8 IIC_Command)
{
	IIC_Start();
	Write_IIC_Byte(0x78);            //Slave address,SA0=0
	IIC_Wait_Ack();                  //等待
	Write_IIC_Byte(0x00);			//write command
	IIC_Wait_Ack();
	Write_IIC_Byte(IIC_Command);
	IIC_Wait_Ack();
	IIC_Stop();
}


// IIC Write Data
void Write_IIC_Data(u8 IIC_Data)
{
	IIC_Start();
	Write_IIC_Byte(0x78);			//D/C#=0; R/W#=0
	IIC_Wait_Ack();
	Write_IIC_Byte(0x40);			//write data
	IIC_Wait_Ack();
	Write_IIC_Byte(IIC_Data);
	IIC_Wait_Ack();
	IIC_Stop();
}
void OLED_WR_Byte(unsigned dat, unsigned cmd)
{
	if(cmd)
		Write_IIC_Data(dat);
	else
		Write_IIC_Command(dat);
}

//初始化SSD1306显示屏
void OLED_Init(void)
{
	OLED_WR_Byte(0xAE, 0); //--display off
	OLED_WR_Byte(0x00, 0); //---set low column address
	OLED_WR_Byte(0x10, 0); //---set high column address
	OLED_WR_Byte(0x40, 0); //--set start line address
	OLED_WR_Byte(0xB0, 0); //--set page address
	OLED_WR_Byte(0x81, 0); // contract control
	OLED_WR_Byte(0xFF, 0); //--128
	OLED_WR_Byte(0xA1, 0); //set segment remap
	OLED_WR_Byte(0xA6, 0); //--normal / reverse
	OLED_WR_Byte(0xA8, 0); //--set multiplex ratio(1 to 64)
	OLED_WR_Byte(0x3F, 0); //--1/32 duty
	OLED_WR_Byte(0xC8, 0); //Com scan direction
	OLED_WR_Byte(0xD3, 0); //-set display offset
	OLED_WR_Byte(0x00, 0); //

	OLED_WR_Byte(0xD5, 0); //set osc division
	OLED_WR_Byte(0x80, 0); //

	OLED_WR_Byte(0xD8, 0); //set area color mode off
	OLED_WR_Byte(0x05, 0); //

	OLED_WR_Byte(0xD9, 0); //Set Pre-Charge Period
	OLED_WR_Byte(0xF1, 0); //

	OLED_WR_Byte(0xDA, 0); //set com pin configuartion
	OLED_WR_Byte(0x12, 0); //

	OLED_WR_Byte(0xDB, 0); //set Vcomh
	OLED_WR_Byte(0x30, 0); //

	OLED_WR_Byte(0x8D, 0); //set charge pump enable
	OLED_WR_Byte(0x14, 0); //

	OLED_WR_Byte(0xAF, 0); //--turn on oled panel
}

//OLED清除

void OLED_Clear(void)
{
	u8 m, n;
	for(m = 0; m < 8; m++)
	{
		OLED_WR_Byte(0xb0 + m, 0);		//page0-page1
		OLED_WR_Byte(0x00, 0);		//low column start address
		OLED_WR_Byte(0x10, 0);		//high column start address
		for(n = 0; n < 128; n++)
		{
			OLED_WR_Byte(0x00, 1);
		}
	}
}
//坐标设置
void OLED_Set_Pos(u8 x, u8 y)
{
	OLED_WR_Byte(0xb0 + y, 0);
	OLED_WR_Byte((((x + 2) & 0xf0) >> 4) | 0x10, 0);
	OLED_WR_Byte(((x + 2) & 0x0f), 0);
}
void OLED_ShowChar(u8 x, u8 y, u8 chr)
{
	u8 c = 0, i = 0;
	c = chr - ' ';        //得到偏移后的值
	if(x > Max_Column - 1)                             
	{
		x = 0;
		y = y + 2;
	}
	OLED_Set_Pos(x, y);
	for(i = 0; i < 8; i++)
		OLED_WR_Byte(zf[c * 16 + i], 1);
	OLED_Set_Pos(x, y + 1);
	for(i = 0; i < 8; i++)
		OLED_WR_Byte(zf[c * 16 + i + 8], 1);

}
/////////////
//m^n函数
u32 oled_pow(u8 m, u8 n)
{
	u32 result = 1;
	while(n--)result *= m;
	return result;
}
//显示数字
//x,y :起点坐标
//len :数字的位数
//num:数值(0~4294967295)
//mode:显示格式：为0，当要显示的最高位为0时显示时，显示空格，为1，当要显示的最高位为0时显示时，显示0 
void OLED_ShowNum(u8 x, u8 y, u32 num, u8 len, u8 mode)
{
	u8 t, temp;
	u8 enshow = 0;
	for(t = 0; t < len; t++)
	{
		temp = (num / oled_pow(10, len - t - 1)) % 10;
		if(enshow == 0 && t < (len - 1))
		{
			if(temp == 0)
			{
				if(mode == 0)
					OLED_ShowChar(x + 8 * t, y, ' ');
				else
					OLED_ShowChar(x + 8 * t, y, '0');
				continue;
			}
			else enshow = 1;
		}
		OLED_ShowChar(x + 8 * t, y, temp + '0');
	}
}
///////////////////////****************************************OLED*****************************//////////////

void init()	   //初始化定时器0 和外部中断0
{
	TMOD = 0x02; //定时器0工作方式2，8位自动重装
	TH0 = 0x00;  //高8位装入0那么定时器溢出一次的时间是256个机器周期
	TL0 = 0x00;
	EA = 1;      //总中断
	ET0 = 1;	   //定时器0中断
	TR0 = 1;     //启动定时器0

	IT0 = 1;	   //设置外部中断0为跳沿触发方式，来一个下降沿触发一次
	EX0 = 1;	   //启动外部中断0
}

void time0() interrupt 1   //定义定时器0
{
	IRtime++; 			   //检测脉宽，1次为278us
}

void int0() interrupt 0	  		//定义外部中断0
{
	static uchar i;	 			//声明静态变量（在跳出函数后在回来执行的时候不会丢失数值）i用于把33次高电平的持续时间存入IRdata
	static bit startflag;		//开始储存脉宽标志位
	if(startflag)	 			//开始接收脉宽检测
	{
		if( (IRtime < 53) && (IRtime >= 32) ) /*判断是否是引导码，底电平9000us+高4500us	
	                                          以11.0592来算NEC协议的引导码低8000-10000+高4000-5000 
		                                   如果已经接收了引导码那么i不会被置0就会开始依次存入脉宽*/
		i = 0;				 //如果是引导码那么执行i=0把他存到IRdata的第一个位
		IRdata[i] = IRtime;  		 //以T0的溢出次数来计算脉宽，把这个时间存到数组里面到后面判断
		IRtime = 0;				 //计数清零，下一个下降沿的时候在存入脉宽
		i++; 					 //计数脉宽存入的次数
		if(i == 33) 				 //如果存入34次 数组的下标是从0开始i等于33表示执行了34次
		{
		 	IRok = 1;				 //那么表示脉宽检测完毕
			i = 0; 				 //把脉宽计数清零准备下次存入
		}
	}
	else		  
	{ 
		IRtime = 0; 				           //引导码开始进入把脉宽计数清零开始计数
		startflag = 1;			              //开始处理标志位置1
	}
}

void IRcordpro()   				          //提取它的33次脉宽进行数据解码
{
	uchar i, j, k, cord, value;	        /*i用于处理4个字节，j用于处理一个字节中每一位，k用于33次脉宽中的哪一位
                                     	cord用于取出脉宽的时间判断是否符合1的脉宽时间*/
	k = 1; 						        //从第一位脉宽开始取，丢弃引导码脉宽
	for(i = 0; i < 4; i++)
	{
		for(j = 0; j < 8; j++)
		{
			cord = IRdata[k];	               //把脉宽存入cord
			if(cord > 5)	 		          //如果脉宽大于我11.0592的t0溢出率为约278us*5=1390那么判断为1
			value = value | 0x80;	         /*接收的时候是先接收最低位，
		                                	把最低位先放到value的最高位在和0x08按位或一下
			                                这样不会改变valua的其他位的数值只会让他最高位为1*/
			if(j < 7)
			{
				value = value >> 1;	        //value位左移依次接收8位数据。
			}
			k++;				           //每执行一次脉宽位加1
		}
		IRcord[i] = value;	              //每处理完一个字节把它放入IRcord数组中。
		value = 0; 			             //清零value方便下次在存入数据
	}
	IRpro_ok = 1;				        //接收完4个字节后IRpro ok置1表示红外解码完成	
}

/********************按键0，cleaning                    // 全部灭********************/
void led_display_0()
{
	P2=0x00;
	OLED_Init();//初始化OLED
	OLED_Clear();//清屏 
	OLED_ShowChar(0, 0, 'c');
	OLED_ShowChar(8, 0, 'l');
	OLED_ShowChar(16, 0, 'e');
	OLED_ShowChar(24, 0, 'a');
	OLED_ShowChar(32, 0, 'n');
	OLED_ShowChar(40, 0, 'i');
	OLED_ShowChar(48, 0, 'n');
	OLED_ShowChar(56, 0, 'g');
	
}
/********************按键1，mode1:on                    // 全部亮********************/
void led_display_1()
{
	P2=0xff;
	OLED_Init();//初始化OLED
	OLED_Clear();//清屏 
	OLED_ShowChar(0, 0, 'm');
	OLED_ShowChar(8, 0, 'o');
	OLED_ShowChar(16, 0, 'd');
	OLED_ShowChar(24, 0, 'e');
	OLED_ShowChar(32, 0, '1');
	OLED_ShowChar(40, 0, ':');
	
	OLED_ShowChar(56, 0, 'o');
	OLED_ShowChar(64, 0, 'n');
}
/******************按键2，mode2:on                 //流水灯，依次点亮******************************/
void led_display_2()                                    
{	
	unsigned int x=0;    //i初定一个值 
	OLED_Init();//初始化OLED
	OLED_Clear();//清屏 

	OLED_ShowChar(0, 0, 'm');
	OLED_ShowChar(8, 0, 'o');
	OLED_ShowChar(16, 0, 'd');
	OLED_ShowChar(24, 0, 'e');
	OLED_ShowChar(32, 0, '2');
	OLED_ShowChar(40, 0, ':');
	
	OLED_ShowChar(56, 0, 'o');
	OLED_ShowChar(64, 0, 'n');
	
                     
	for(x=0;x<8;x++)                         //i=8,循环8次
	{
		P2=0x01<<x; 

		delay(500);                      //第一次循环，x=0,不移位，0001第一个灯亮
		
		
//*****************************************重新检测按键，按"OK"灯全灭*******************************//
//			if(IRok)    //判断脉宽是否检测完毕                    
//			{   
//				IRcordpro();//根据脉宽解码出4个字节的数据
//				IRok = 0;	//重新等待脉宽检测
//				if(IRpro_ok) //判断是否解码完毕  
//				{
//					switch(IRcord[2])
//					{                                                           //起始灯全亮，检测电路
//						
//						case 0x1C: P2=0x00;break;                               //按"OK"灯全灭
//						default:continue;
//					}
//				}
//			}				
	};

}

/******************按键3，mode3:on            //累加流水灯，挨个叠加灯亮，最后全部闪两下**********************/
void led_display_3()
{
	unsigned int i=0;
	OLED_Init();//初始化OLED
	OLED_Clear();//清屏 

	OLED_ShowChar(0, 0, 'm');
	OLED_ShowChar(8, 0, 'o');
	OLED_ShowChar(16, 0, 'd');
	OLED_ShowChar(24, 0, 'e');
	OLED_ShowChar(32, 0, '3');
	OLED_ShowChar(40, 0, ':');
	
	OLED_ShowChar(56, 0, 'o');
	OLED_ShowChar(64, 0, 'n');
	for(i=0;i<50;i++)
	{
		P2=leddat_2[i];//数组中的第几个元素 
		delay(200);  //灯亮的时间 
	}	
}
/**********按键4，mode4:on                    //奇偶流水灯，从上到下，奇数灯亮后从下到上，偶数灯亮**************/
void led_display_4()
{
	unsigned char i=0,j=0;
	OLED_Init();//初始化OLED
	OLED_Clear();//清屏 

	OLED_ShowChar(0, 0, 'm');
	OLED_ShowChar(8, 0, 'o');
	OLED_ShowChar(16, 0, 'd');
	OLED_ShowChar(24, 0, 'e');
	OLED_ShowChar(32, 0, '4');
	OLED_ShowChar(40, 0, ':');
	
	OLED_ShowChar(56, 0, 'o');
	OLED_ShowChar(64, 0, 'n');
                                       //实现 从右到左,（从上到下） 奇数灯灭 1 3 5 7
	for(j=0;j<2;j++)                   //循环两次
	{
		P2=0x01;
		for(i=0;i<8;)
		{
			delay(600);
			P2=P2<<2;
			i=i+2;
		}
										   //从左到右（从下到上） 偶数灯灭 8 6 4 2  
		P2=0x7f;                           //0111 1111
		P2=~P2;                            //取反，从另一头开始
		for(i=8;i>0;)
		{
			delay(600);
			P2=P2>>2;
			i=i-2;
		}	
	}	   	
}
/********************按键*，turn on                    // 全部亮********************/
void led_display_on()
{
	P2=0xff;
	OLED_Init();//初始化OLED
	OLED_Clear();//清屏
	OLED_ShowChar(0, 0, 't');
	OLED_ShowChar(8, 0, 'u');
	OLED_ShowChar(16, 0, 'r');
	OLED_ShowChar(24, 0, 'n');
	OLED_ShowChar(40, 0, 'o');
	OLED_ShowChar(48, 0, 'n');
		
}
/********************按键#，turn off                    // 全部灭********************/
void led_display_off()
{
	P2=0x00;
	OLED_Init();//初始化OLED
	OLED_Clear();//清屏
	OLED_ShowChar(0, 0, 't');
	OLED_ShowChar(8, 0, 'u');
	OLED_ShowChar(16, 0, 'r');
	OLED_ShowChar(24, 0, 'n');
	OLED_ShowChar(40, 0, 'o');
	OLED_ShowChar(48, 0, 'f');
	OLED_ShowChar(56, 0, 'f');
}
/********************按键OK，B18021129                   // 闪两下********************/
void led_display_ok()
{
	OLED_Init();//初始化OLED
	OLED_Clear();//清屏 
	OLED_ShowChar(32, 4, 'B');
	OLED_ShowNum(40, 4, 18021129, 8, 1);
	P2=0xff;
	delay(500);
	P2=0x00;
	delay(500);
	P2=0xff;
	delay(500);
	P2=0x00;
	delay(500);
}

/*******************主函数**************************/ 
void main() 
{ 	
	OLED_Init();                                  //初始化OLED
	OLED_Clear();                                 //清屏 

	OLED_ShowChar(0, 0, 'e'); 				      //OLED显示
	OLED_ShowChar(8, 0, '-');
	OLED_ShowChar(16, 0, 'l');                   //坐标每次加8 
	OLED_ShowChar(24, 0, 'y');
	OLED_ShowChar(32, 0, 'l');
	OLED_ShowChar(40, 0, 'g');
//		OLED_ShowChar(48, 0, 'l');
//		OLED_ShowChar(56, 0, 'i');
	
	OLED_ShowChar(0, 4, 'Z');                      //坐标每次加8 
	OLED_ShowChar(8, 4, 'C');
	OLED_ShowChar(16, 4, 'S');
	OLED_ShowChar(24, 4, ':');
	OLED_ShowChar(32, 4, 'B');
	OLED_ShowNum(40, 4, 18021129, 8, 1);

	
//	unsigned int n=0;                          //循环次数
	init();                                                                	//执行初始化定时器0和外部中断0
	while(1) 
	{ 
		if(IRok)                                                            //判断脉宽是否检测完毕                    
		{   
			IRcordpro();                                                    //根据脉宽解码出4个字节的数据
			IRok = 0;	                                                    //重新等待脉宽检测
			if(IRpro_ok)                                                    //判断是否解码完毕  
			{
		        switch(IRcord[2])
		   		{                                                           //起始灯全亮，检测电路
					case 0X19: led_display_0();break;                       //按“0”全灭	cleaning	
				    case 0x45: led_display_1();break;                       //按"1"灯全亮   mode 1
				    case 0x46: led_display_2();break;                       //按“2”进入流水灯2模式	
					case 0x47: led_display_3();break;						//按“3”进入流水灯3模式
					case 0x44: led_display_4();break;                       //按“4”进入流水灯4模式
					case 0x16: led_display_on();break;                      //按“*”灯亮屏turn on
					case 0x0d: led_display_off();break;                     //按“#”灯灭屏turn off
					case 0x1c: led_display_ok();break;                      //按“ok”显示学校学号
						 
//						 while(n)
//						 {
//							led_display_1();
//							switch(IRcord[1])
//							{
//								case 0x1C:n=0;break;         //按“OK”退出流水灯模式
//							}
//						 };
//					 for(n=0;n<2;n++)                         //循环2次退出流水灯模式
//					 {
//						led_display_1();
//					 }
					 
					 
					
					//case 0X1C: break;

					default:break;
		   		}
				IRpro_ok = 0;
			}
		}	
	}
} 


/******************z 秒延时函数*************************/ 
void delay(unsigned int z) 
{ 
	unsigned int x,y; 
	for(x=z;x>0;x--) 
		for(y=110;y>0;y--); 
} 
/****************微妙延时******************************/ 
void delay_us(unsigned int aa) 
{ 
	while(aa--); 
}

